# 运维工程师面试题及答案汇总

## 1. 修改ip地址

立即生效而重启失效 rhel6 or rhel7:

```shell
[root@rhel6 ~]#  ifconfig eth0 192.168.1.155 netmask 255.255.255.0	#note:rhel6.
```

```shell
[root@rhel7 ~]#  ifconfig eno16777736 192.168.1.155 netmask 255.255.255.0	#note:rhel7.
```

重启网卡服务或Linux生效 rhel6 or rhel7:

```shell
[root@rhel6 ~]# vim /etc/sysconfig/network-scripts/ifcfg-eth0	#note:rhel6.
[root@rhel6 ~]# service network restart or /etc/init.d/network restart
```

```shell
[root@rhel7 ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736	#note:rhel7.
[root@rhel7 ~]# systemctl restart network
```

## 2. 修改网关GATEWAY

立即生效而重启失效:

```shell
[root@rhel6 ~]# route add default gw 192.168.1.1			#note:rhel7同rhel6.
```

重启网卡服务或Linux生效:

```shell
[root@rhel6 ~]# vim /etc/sysconfig/network-scripts/ifcfg-eth0	#note:rhel7同rhel6.
[root@rhel6 ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
NAME=eht0
DEVICE=eth0
TYPE=Ethernet
UUID=f91bb5c4-868c-457d-bdfa-93aeadc24023
ONBOOT=yes
NM_CONTROLLED=yes
BOOTPROTO=DHCP
NETMASK=255.255.255.0
GETWAY=192.168.80.2		#note:修改了此项默认网关。
[root@rhel6 ~]# service restart network or /etc/init.d/network restart

如下网卡信息：
[root@localhost network-scripts]# cat ifcfg-em1
HWADDR=18:66:DA:EC:AE:E4
TYPE=Ethernet
BOOTPROTO=static
DEFROUTE=yes
PEERDNS=yes
PEERROUTES=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes
IPV6_FAILURE_FATAL=no
NAME=em1
UUID=657ab0ef-c66a-4480-874c-4371d0042ced
ONBOOT=yes
IPADDR=192.168.189.100
GATEWAY=192.168.189.1
NETMASK=255.255.255.0
DNS1=114.114.114.114
```

## 3. 修改DNS域名解析

重启网卡服务或Linux生效 rhel6同rhel7:

```shell
1. 可以直接修改/etc/hosts文件，直接添加IP地址和对应的域名
2. 可以修改网卡配置文件/etc/sysconfig/network-scripts/ifcfg-eth0
添加或修改DNS1=xxx.xxx.xxx.xxx字样保存退出，重启网络服务
3. 也可以修改/etc/resolv.conf文件 添加nameserver  xxx.xxx.xxx.xxx 字样保存退出
[root@rhel6 ~]# echo "nameserver 202.16.53.68" >> /etc/resolv.conf
DNS生效顺序是：
1 hosts文件 ---- 2 /etc/sysconfig/network-scripts/下的网卡配置文件 ---3 /etc/resolv.conf
```

## 4. 修改主机名Hostname

立即生效而重启失效:

```shell
[root@rhel6 ~]# hostname 
rhel6
[root@rhel6 ~]# hostname test1		#note:rhel7同rhel6.
[root@rhel6 ~]# hostname
test1
```

重启生效:

```shell
[root@rhel6 ~]# vim /etc/sysconfig/network		#note:rhel6.
[root@rhel6 ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=rhel6
```



```shell
[root@rhel7 ~]# hostname						#note:rhel7.
rhel7
[root@rhel7 ~]# cat /etc/hostname
rhel7
[root@rhel7 ~]# vim /etc/hostname
[root@rhel7 ~]# cat /etc/hostname
rhel7.2
[root@rhel7 ~]# hostname						#note:rhel7修改后可立即生效.
rhel7.2
[root@rhel7 ~]# hostnamectl status
   Static hostname: rhel7.2
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 1317e0cf57e84aab84bb57ff06b2563a
           Boot ID: 8cefd7b8f5df4ed2abbb634f2ff12009
    Virtualization: vmware
  Operating System: Red Hat Enterprise Linux Server 7.2 (Maipo)
       CPE OS Name: cpe:/o:redhat:enterprise_linux:7.2:GA:server
            Kernel: Linux 3.10.0-327.el7.x86_64
      Architecture: x86-64
```

## 5. 修改服务启动/不启动状态

**5.1 开机启动/不启动以及当前启动或停止**

```shell
[root@rhel6 ~]# chkconfig NetworkManager on				#note:rhel6设置服务开机启动.
[root@rhel6 ~]# chkconfig --level 5 NetworkManager off
[root@rhel6 ~]# chkconfig --list
NetworkManager 0:off	1:off	2:on	3:on	4:on	5:off	6:off
abrt-ccpp      0:off	1:off	2:off	3:on	4:off	5:on	6:off
abrtd          0:off	1:off	2:off	3:on	4:off	5:on	6:off
[root@rhel6 ~]# chkconfig --level 5 sshd off
[root@rhel6 ~]# chkconfig --list | grep sshd
sshd           	0:off	1:off	2:on	3:on	4:on	5:off	6:off
[root@rhel6 ~]# service --status-all					#note:查看服务的现有运行状态.
[root@rhel6 ~]# service sshd stop						#note:rhel6设置服务当前停止。
Stopping sshd:                                             [  OK  ]
[root@rhel6 ~]# service sshd start						#note:rhel6设置服务当前启动.
Starting sshd:                                             [  OK  ]
[root@rhel6 ~]# service sshd status
openssh-daemon (pid  6631) is running...
```

说明：rhel7启用服务就是在当前 runlevel 的配置文件目录/etc/systemd/system/multi-user.target.wants/里，建立/usr/lib/systemd/system里面对应服务配置文件的软链接，禁用服务就是删除此软链接：

　　启动一个服务：systemctl start postfix.service

　　关闭一个服务：systemctl stop postfix.service

　　重启一个服务：systemctl restart postfix.service

　　显示一个服务的状态：systemctl status postfix.service

　　在开机时启用一个服务：systemctl enable postfix.service

　　在开机时禁用一个服务：systemctl disable postfix.service

　　查看服务是否开机启动：systemctl is-enabled postfix.service;echo $?

　　查看开机启动的服务列表：systemctl list-unit-files|grep enabled		#note:相当于rhel6中的c

```shell
[root@rhel7 system]# systemctl status -all	#:note:或直接systemctl，查看服务的现有运行状态.
[root@rhel7 system]# systemctl status -all | grep httpd
[root@rhel7 system]# systemctl enable httpd				#note:rhel7设置服务开机启动.
[root@rhel7 system]# systemctl disable httpd				#note:rhel7设置服务开机不启动.
Removed symlink /etc/systemd/system/multi-user.target.wants/httpd.service.
[root@rhel7 system]# systemctl is-enabled sshd			#note:rhel7查看一个服务是否开机启动。
enabled
[root@rhel7 system]# systemctl start httpd				#note:rhel7设置服务当前启动.
[root@rhel7 system]# systemctl stop httpd				#note:rhel7设置服务当前停止.
[root@rhel7 system]# systemctl status httpd
● httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
     Docs: man:httpd(8)
           man:apachectl(8)
```

## 6. 修改系统启动/运行等级runlevel

**rhel6**

​	**7个运行级别(runlevel)**

​		运行级别0：halt系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
​		运行级别1：Single user mode单用户工作状态，root权限，用于系统维护，禁止远程登陆
​		运行级别2：Multiusers 多用户状态(没有NFS)
​		运行级别3：Multiusers 完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
​		运行级别4：unused系统未使用，保留
​		运行级别5：Multiusers with GUI，graphical target，X11控制台，登陆后进入图形GUI模式；
​		运行级别6：reboot系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动；

```shell
[root@rhel6 ~]# cat /etc/inittab

# inittab is only used by upstart for the default runlevel.
# Default runlevel. The runlevels used are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
```

**rhel6切换当前模式到其它等级**

查看运行级别用：runlevel
进入其它运行级别用：init N

```shell
[root@rhel6 ~]# runlevel 
N 5
[root@rhel6 ~]# init 3
[root@rhel6 ~]# runlevel 
5 3
```

**rhel6修改默认启动运行等级**

修改/etc/inittab配置文件，或用telinit N命令即可，

```shell
[root@rhel6 ~]# cat /etc/inittab 		#note将最后一行的等级数字修改重启即可。

# inittab is only used by upstart for the default runlevel.
....................省略.............................
# Default runlevel. The runlevels used are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
# 
id:5:initdefault:
[root@rhel6 ~]# telinit 3
```



**rhel7**

inittab在rhel7中已不在使用，而被systemctld统一管理，

```shell
[root@rhel7 ~]# cat /etc/inittab 
# inittab is no longer used when using systemd.
#
# ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.
#
# systemd uses 'targets' instead of runlevels. By default, there are two main targets:
#
# multi-user.target: analogous to runlevel 3
# graphical.target: analogous to runlevel 5
#
# To view current default target, run:
# systemctl get-default

# To set a default target, run:
# systemctl set-default TARGET.target
```

**rhel7切换当前模式到其它等级**

```shell
[root@rhel7 ~]# runlevel							#note:查看当前运行等级，同rhel7。
N 5
[root@rhel7 ~]# systemctl get-default 				#note:查看当前运行等级，同上。
graphical.target

[root@rhel7 ~]# init 3	#note:同systemctl isolate multi-user.target
[root@rhel7 ~]# systemctl isolate mutil-user.target	
#note:切换当前系统登录模式为runlevel3，也可以用systemctl isolate runlevel3.target

[root@rhel7 ~]# init 5	#note:同systemctl isolate graphical.target
[root@rhel7 ~]# systemctl isolate runlevel5.target
#note:切换当前系统登录模式为runlevel5，也可以用systemctl isolate graphical.target
```

**rhel7修改默认启动运行等级**

```shell
# To set a default target, run:               #运行下面 命令设置默认开机启动级别
#
# ln -sf /lib/systemd/system/.target /etc/systemd/system/default.target

 /lib/systemd/system/   里面有0-6 六个级别的文件软连接
runlevel0.target         poweroff
runlevel1.target         rescue
runlevel2.target         multi-user
runlevel3.target         multi-user
runlevel4.target         multi-user
runlevel5.target         graphical
runlevel6.target         reboot
例如：修改5级别： ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target
例如：修改3级别： ln -sf /lib/systemd/system/runlevel3.target /etc/systemd/system/default.target
或用systemctl set-default multi-user，
```

```shell
[root@rhel7 system]# ls -l $PWD | sed -n '/runlevel/p' | grep '^l'
lrwxrwxrwx. 1 root root   15 Jan 23 00:08 runlevel0.target -> poweroff.target
lrwxrwxrwx. 1 root root   13 Jan 23 00:08 runlevel1.target -> rescue.target
lrwxrwxrwx. 1 root root   17 Jan 23 00:08 runlevel2.target -> multi-user.target
lrwxrwxrwx. 1 root root   17 Jan 23 00:08 runlevel3.target -> multi-user.target
lrwxrwxrwx. 1 root root   17 Jan 23 00:08 runlevel4.target -> multi-user.target
lrwxrwxrwx. 1 root root   16 Jan 23 00:08 runlevel5.target -> graphical.target
lrwxrwxrwx. 1 root root   13 Jan 23 00:08 runlevel6.target -> reboot.target
[root@rhel7 system]# systemctl get-default 
graphical.target
[root@rhel7 system]# systemctl set-default multi-user.target
Removed symlink /etc/systemd/system/default.target.
Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target.
[root@rhel7 system]# systemctl get-default 
multi-user.target
```

## 7. MySQL的版本

红帽6的MySQL版本为MySQL5.1，红帽7的MySQL为MariaDB 5.5.

## 8. 修改默认访问端口/防火墙

修改防火墙规则并重启和保存--修改相应服务的配置文件并重启服务--重启，如下例子，

```shell
1、防火墙开放端口
在这里我们是要将默认的ssh端口22修改为2121，所以要将2121端口在防火墙打开
# /sbin/iptables -I INPUT -p tcp --dport 2121 -j ACCEPT
# /etc/rc.d/init.d/iptables save
# sed -i "/A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT/d" /etc/sysconfig/iptables
# service iptables restart
2、修改sshd_config文件
# sed -i 's/#Port 22/Port 2121/' /etc/ssh/sshd_config
3、重启SSH服务
#  service sshd restart
这个时候就无法使用22端口进行ssh远程连接，必须使用2121端口。

[root@rhel6 .ssh]# /sbin/iptables -I INPUT -p tcp --dport 2121 -j ACCEPT
[root@rhel6 .ssh]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]
[root@rhel6 .ssh]# sed -i "/A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT/d" /etc/sysconfig/iptables
[root@rhel6 .ssh]# sed -i 's/#Port   22/Port 2121/' /etc/ssh/sshd_config
#或者echo "Port 2121" >> /etc/ssh/sshd_config
[root@rhel6 ~]# grep ^Port /etc/ssh/sshd_config
Port 2121
[root@rhel6 ~]# service iptables reload
iptables: Trying to reload firewall rules:                 [  OK  ]
[root@rhel6 ~]# service sshd reload
Reloading sshd:                                            [  OK  ]
#用Xshell再次进行连接，22端口已连不上，2121端口可以连上，
[c:\~]$ 
Connecting to 192.168.80.128:22...
Could not connect to '192.168.80.128' (port 22): Connection failed.

[c:\~]$ 
Connecting to 192.168.80.128:2121...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.
Last login: Fri Mar 10 22:16:34 2017 from 192.168.80.1
[root@rhel6 ~]# 
```

rhel7开放防火墙firewalld, firewall-cmd端口的方法

```shell
#rhel7修改开放端口的方法
Centos升级到7之后，发现无法使用iptables控制Linuxs的端口，google之后发现Centos 7使用firewalld代替了原来的iptables。下面记录如何使用firewalld开放Linux端口：
查看所有已开放的端口
firewall-cmd --zone=public --list-ports
开启端口
firewall-cmd --zone=public --add-port=80/tcp --permanent
but if is a known service, you can use:
firewall-cmd --permanent --zone=public --add-service=http 
命令含义：
--zone #作用域
--add-port=80/tcp  #添加端口，格式为：端口/通讯协议
--permanent   #永久生效，没有此参数重启后失效
重启防火墙
firewall-cmd --reload

详细信息可以参考以下资料：

http://stackoverflow.com/questions/24729024/centos-7-open-firewall-port
https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html

莫小安
CentOS7使用firewalld打开关闭防火墙与端口

1、firewalld的基本使用
启动： systemctl start firewalld
查看状态： systemctl status firewalld 	或 firewall-cmd --state
停止： systemctl disable firewalld
禁用： systemctl stop firewalld
 
2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。
启动一个服务：systemctl start firewalld.service
关闭一个服务：systemctl stop firewalld.service
重启一个服务：systemctl restart firewalld.service
显示一个服务的状态：systemctl status firewalld.service
在开机时启用一个服务：systemctl enable firewalld.service
在开机时禁用一个服务：systemctl disable firewalld.service
查看服务是否开机启动：systemctl is-enabled firewalld.service
查看已启动的服务列表：systemctl list-unit-files|grep enabled
查看启动失败的服务列表：systemctl --failed

3.配置firewalld-cmd

查看版本： firewall-cmd --version
查看帮助： firewall-cmd --help
显示状态： firewall-cmd --state
启动一个服务：firewall-cmd --add-service=http
禁止home区域中的http服务：firewall-cmd --zone=home --remove-service=http
查看所有打开的端口： firewall-cmd --zone=public --list-ports
更新防火墙规则： firewall-cmd --reload
查看区域信息:  firewall-cmd --get-active-zones
查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0
拒绝所有包：firewall-cmd --panic-on
取消拒绝状态： firewall-cmd --panic-off
查看是否拒绝： firewall-cmd --query-panic
 
那怎么开启一个端口呢
添加
firewall-cmd --zone=public --add-port=80/tcp --permanent    （--permanent永久生效，没有此参数重启后失效）
firewall-cmd --zone=public --add-port=80-800/tcp --permanent #开放多个连续端口
#rhel6:开放多个连续端口 iptables -I INPUT -p tcp --dport 2121：3000 -j ACCEPT
firewall-cmd --permanent --zone=public --add-port=100-500/tcp --permanent
firewall-cmd --permanent --zone=public --add-port=100-500/udp --permanent
firewall-cmd --reload
重新载入
firewall-cmd --reload
查看
firewall-cmd --zone= public --query-port=80/tcp
删除
firewall-cmd --zone= public --remove-port=80/tcp --permanent
```



## 9. Port服务的默认端口

SSH 22，Telnet 23，SMTP 25，POP3 110，DNS 53，远程桌面 3389，MySQL 3306，HTTPS 443，Apache(httpd) 80，Nginx 80，Tomcat 8080，Tomcat的ssl端口为8443(因为ssl的为443则Tomcat直接前面加8)

git或gitlab由于是基本ssh协议故端口是22

## 10. 查询文件 

**10.1 文件file1**，①查询file1里面的空行所在行号，②查询file1以abc结尾的行，③打印file1文件的第1到3行；

①查询file1里面的空行所在行号

```shell
[root@rhel6 ~]# cat test2
/\hello@/\world.hi
abc

/\/\hehe/abc\end
[root@rhel6 ~]# grep -n ^$ test2 | awk -F ':' '{print $1}'
3
[root@rhel6 ~]# grep -n ^$ test2 
3:
[root@rhel6 ~]# grep -n "^$" test2 
3:
```

②查询file1以abc结尾的行，

```shell
[root@rhel6 ~]# cat test2
/\hello@/\world.hi
abc

  .abc
/\/\hehe/abc\end
[root@rhel6 ~]# grep abc$ test2
abc
  .abc
[root@rhel6 ~]# grep -n abc$ test2
2:abc
4:.abc
[root@rhel6 ~]# grep -n ".*abc$" test2
2:abc
4:.abc
```

③打印file1文件的第1到3行,

```shell
[root@rhel6 ~]# cat test2
/\hello@/\world.hi
abc
a
  .abc
/\/\hehe/abc\end
[root@rhel6 ~]# sed -n '1,3p' test2
/\hello@/\world.hi
abc
a
[root@rhel6 ~]# head -n 3 test2
/\hello@/\world.hi
abc
a
```

## 11. Route添加路由表

查看当前Linux系统的路由表，添加一条路由表10.1.1.0/24，网关为10.1.1.0，

```shell
[root@rhel6 ~]# route add -net 10.1.1.0/24 gw 10.10.10.1
```

## 12. find和crontab周期性计划任务

**12.1 写出此条crontab命令的意思 0 3 * * * root find /corefile -mtime +4 -type f | xargs rm -f**

周期性计划任务 * * * * *代表分时日月周，mtime的m代表modifyd而time代表24hours，

这里指每天凌晨3点，查找corefile目录下修改时间超过4天的文件，然后执行删除，注意此任务是错误的，因为**不应有root**，应为0 3 * * * root find /corefile -mtime +4 -type f | xargs rm -f，这里的find等shell命令不用写绝对路径即不用写/bin/find，管道|是实现“将前面的标准输出作为后面的标准输入，”xargs是实现“将标准输入作为命令的参数”，当你尝试用rm等命令删除或处理太多的文件，可能会报错而xargs可以解决这个问题。

周期性计划任务创建方法：在命令行输入crontab -e后会弹出可编辑的对话框，在里面直接输入0 3 * * *  find /corefile -mtime +4 -type f | xargs rm -f 即可，例如，

```shell
# find -mtime -n +n

按照文件的更改（modified time）时间来查找文件，-n表示文件更改时间距现在n天以内，+n表示文件更改时间距现在n天以前。这个命令和atime，ctime差不多。其中atime是指access time，ctime是指changed time。值得注意的是他们的单位都是24小时，这个是和"天"有点区别的。
```

```shell
[root@rhel6 ~]# crontab -e		#note: e代表edit编辑任务
no crontab for root - using an empty one
crontab: installing new crontab
[root@rhel6 ~]# crontab -l		#note: l代表list列出所有的任务
0 3 * * * find /corefile -mtime +4 -type f | xargs rm -f 
[root@rhel6 ~]# crontab -r		#note: r代表remove删除所有的任务
```

```shell
在11月份内，每天的早上6点到12点中，每隔2小时执行一次/usr/bin/httpd.sh,
0 6-12/2 * 11 * /usr/bin/httpd.sh 
```

## 13. RAID磁盘阵列

**13.1 给你6个150G的硬盘，列出RAID排列方式，哪种方式容量最大，并解释其它方式的容量**

```shell
答：6块硬盘全部利用无法做出RAID01个陈列。
最大只能做RAID0：容量150G*4=600G，
RAID5容量150G*（6-1）=750G，
RAID0+1即RAID10或RAID01容量为150G*（6/2）=450G，
所以答案是RAID5.

RAID0就是叠加6*150G=900G，RAID0容量最高但牺牲/损失的是可靠性，任意一块坏了则所有数据都会丢失。
RAID1

RAID 0：磁盘叠加，至少需要两块磁盘，无差错控制的带区组，做RAID分区的磁盘大小最好是相同的
将一个数据分为两份分别放在两块硬盘上，tfdn 
。不需要计算校验码。

RAID1
RAID 1：镜象结构
类似于备份模式，一个数据被复制到两块硬盘上。

RAID10	#note:这里是raid一零，不是raid十.
RAID10:高可靠性与高效磁盘结构
一个带区结构加一个镜象结构，因为两种结构各有优缺点，因此可以相互补充。
主要用于容量不大，但要求速度和差错控制的数据库中。

RAID5
RAID5：分布式奇偶校验的独立磁盘结构
它的奇偶校验码存在于所有磁盘上，任何一个硬盘损坏，都可以根据其它硬盘上的校验位来重建损坏的数据。支持一块盘掉线后仍然正常运行。

磁盘阵列（Redundant Arrays of Independent Disks，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。

磁盘阵列是由很多价格较便宜的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。

RAID-0：磁盘叠加

至少需要两块磁盘，做RAID分区的大小最好是相同的（可以充分发挥并优势）;而数据分散存储于不同的磁盘上，在读写的时候可以实现并发，所以相对其读写性能最好；但是没有容错功能，没有冗余功能，如果一个磁盘（物理）损坏，将损坏全部数据则所有的数据都无法使用。

RAID-1：镜像备份

至少需要两块硬盘，raid大小等于两个raid分区中最小的容量（最好将分区大小分为一样），可增加热备盘提供一定的备份能力；数据有冗余，在存储时同时写入两块硬盘，实现了数据备份；但相对降低了写入性能，但是读取数据时可以并发，几乎类似于raid-0的读取效率

RAID-5：效能与数据备份的均衡考虑

至少需要三个以上的磁盘才能够组成这种类型的磁盘阵列。这种磁盘阵列的数据写入有点类似 RAID-0， 不过每个循环的写入过程中，在每颗磁盘还加入一个校验数据(Parity)，

且只有同时损坏两块硬盘时数据才会完全损坏，只损坏一块硬盘时，系统会根据存储的奇偶校验位重建数据，临时提供服务；此时如果有热备盘，系统还会自动在热备盘上重建故障磁盘上的数据
```

## 14. Linux启动过程

开启电源 --> BIOS开机自检 --> 引导程序lilo或grub --> 内核的引导（kernel boot）--> 执行init（rc.sysinit、rc）--> mingetty(建立终端) --> shell

## 15. DATE日期

查询昨天的日期

```shel
[root@rhel7 ~]# date --date=yesterday	#note:查询昨天的
Sun Feb 12 19:20:11 CST 2017
[root@rhel7 ~]# date	#note:查询当时的
Mon Feb 13 19:20:18 CST 2017
```

## 16. Apache访问量最多的IP

**统计Apache的access.log中访问量最多的5个IP**

apache的日志格式，

```shell
[root@rhel7 ~]# cd /var/log/httpd
[root@rhel7 httpd]# ls
access_log  access_log-20170212  error_log  error_log-20170212
[root@rhel7 httpd]# cat access_log
172.16.119.8 - dmin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE HTTP/1.1" 207 649
```

统计有两种方法分别用cut或awk，

```shell
[root@rhel7 httpd]# cat access_log
172.16.119.8 - dmin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE HTTP/1.1" 207 649
172.16.119.8 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default
172.16.119.9 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default
172.16.119.10 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default
172.16.119.11 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default 
172.16.119.8 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default
172.16.119.12 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default
172.16.119.13 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default
172.16.119.8 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default
172.16.119.14 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default
172.16.119.15 - admin [15/Aug/2011:18:17:50 +0800] "PROPFIND /svn/EAGLE/!svn/vcc/default
[root@rhel7 httpd]# cat access_log | awk '{print $1}' | sort | uniq -c | sort -nr | head -n 5
      4 172.16.119.8
      1 172.16.119.9
      1 172.16.119.15
      1 172.16.119.14
      1 172.16.119.13
[root@rhel7 httpd]# cat access_log | cut -d ' ' -f 1 | sort | uniq -c | sort -nr | head -n 5
      4 172.16.119.8
      1 172.16.119.9
      1 172.16.119.15
      1 172.16.119.14
      1 172.16.119.13
```

awk  '{print $1}'  表示打印默认以空格或tab为分割的第1个字段，其它分割符则用awk -F ':' '{print xx}'。

cut  -d  '  ' -f 1 中的-d指定义分割符这里定义分割符为空格，注意引号' '之间要有空格，-f 与-d一起使用，指定显示哪个区域，这个指第1个字段。

uniq 指去除重复的行并打印出来，但重复的行必须是连续的行，所以要先用sort排序，uniq -c是去除重复的行并统计打印出重复的次数。

sort -nr 中的sort -n表示按数据从大到小排列，-r表示逆向显示。

## 17. shell脚本for i in，find

编写个shell脚本将/usr/local/test目录下大于100K的文件转移到/tmp目录下。

```shell
#/bin/bash
find /media/test/ -size +100k -type f -exec mv {} /tmp \;
#note:一条find命令搞定，不过注意find命令是在目录结构中搜索文件和目录，并执行指定的操作，也就是说find会对目录内的所有文件和目录及其字目录进行全部搜索即用find则会对/usr/local/test目录及其字目录字字目录都进行查找出大于100k的文件然后把大于100k的都进行移动到/tmp。同时+100k表示大于100k，-100k表示小于100k，没有+或-即直接写100K表示等于100k，-type f表示类型为文件，-type d表示类型为目录，{}是特定表示方法表示find的输出，\;是特定格式即如果有-exec执行操作则后面要有\;且注意分号;不能少。

[root@zhaowei test]# find . -name "[a-c].*"
[root@zhaowei test]# find ./ -perm 744		#-perm 按权限查找
```

```shell
#!/bin/bash
for file in `ls /usr/local/test`
do
if [ -f $file ]
then
if [ `ls -l $file | awk '{print $5}'` -gt 102400 ]
then
cp $file /tmp
fi
fi
done
```

```shell
if语句格式为if then if then else fi fi，
关于if语句的判断，
     数字的判断     字符的判断     文件的判断
    -gt 大于        -z 空         -d 文件是不是一个目录
    -ge 大于等于    =  字符相等    -f 是不是一个普通文件
    -lt 小于       != 字符不相等   -e 文件是不是存在
    -le 小于等于    -n 非空     
    -ne 不等于     -a 逻辑与 
    -eq 等于       -o 逻辑或
注意 ：
[ ] 括号内的两边有空格

for语句的格式为for i in `` do done，注意这个引号是~下面的反引号。
```



## 18. 执行命令mv inode

**假定Apache产生的日志文件名为access_log.在apache正在运行时，执行命令mv access_log access_log.bak，执行完毕后，请问新的apache的日志会打印到哪里？为什么？**

答：前提是使用mv命令搬移的文件目地跟原文件在同一文件系统内，1.系统会新建一个目录项，将新档案名称对应到inode number（注意：inode number并没有变，只是对应了新的名字）；2. 删除旧档案：搬移档案的行为对inode table任何影响，也不会将档案搬移到其他的block），

由此看来，access_log和access_log.bak是两个不同的文件，其实他们是同一文件，只是换了名字而已。由于程序打开的fd指向原来的Inode，而mv操作并不会改变这个inode只是交这个原inode对应到了access_log.bak文件。

## 19. 挂载windows的共享目录

```shell
mount -t cifs -o username=xxx,password=xxxx //1.1.1.1/a /mnt
mount.cifs //192.168.1.3/a /mnt/ -o user=administrator,pass=123456 
注意这里注意是把windows下的共享目录挂载到Linux里面，用mount cifs方式；如果是把Linux里面的文件/目录共享(或挂载)给windows则用samba.

在Linux下使用mount命令挂载Windows 上的共享文件夹。本经验使用Redhat Linux6.7和windows7作为实践平台。

第一步：Windows7上面：
比如我把D盘中的download文件夹中的share文件夹共享D:\download\share，
右键点击share--在弹出的对话框中点击"共享和安全"--"共享"--"共享此文件夹"--"共享名"为share或自定义--点击"确定"即可，
如果此电脑的ip为192.168.80.128则共享文件夹的网络路径为//192.168.80.128/share而不用写绝对路径D:\download\share。
查看共享文件夹的方式：我的电脑--共享文件夹--共享。
查看ip地址：左下角“开始”--运行run--cmd--ipconfig，不同于Linux的ifconfig.

第二步：在linux 下创建挂载目录，然后就可以直接挂载了，

mount -t cifc 挂载源"windows共享文件夹" 挂载点"Linux /mnt路径"，例如mount -t cifs //16.187.190.60/test /mnt/，
1.[root@ALL /]# mkdir /windows 
2.[root@ALL /]# ll / | grep windows 
3.drwxrwxrwx 1 root root 8192 05-14 08:57 windows 
4.[root@ALL /]# mount -t cifs -o username=administrator,password=admin //200.120.75.24/share/ /windows/
1.[root@ALL /]# cd /windows/ 
2.[root@ALL windows]# ll 
3.总计 3310028 
4.-rwxrwSrwx 1 root root 75838 01-19 16:02 1002_XuanYuan_Sword_Han_Cloud.TORRENT 
5.-rwxrwSrwx 1 root root 890953 2011-07-08 1156-anqn.rar 
6.-rwxrwSrwx 1 root root 3570798 2011-07-08 3739-anqn.rar 
7.-rwxrwSrwx 1 root root 58975174 2011-11-29 AdbeRdr1010_zh_CN.zip 
8.-rwxrwSrwx 1 root root 2615951 2011-07-18 BookShopOnline11.rar 
9.-rwxrwSrwx 1 root root 17477246 2008-03-13 EasyRecoveryPro6.10.07_HA_Setup.exe 
10.-rwxrwSrwx 1 root root 28595201 2011-11-23 filerecover.zip 
11.-rwxrwSrwx 1 root root 134173 2011-06-09 kd drivers.zip 
12.-rwxrwSrwx 1 root root 1212061912 01-31 13:20 mir2_Setup20110928.exe 
13.-rwxrwSrwx 1 root root 161203141 2005-07-12 office2003.exe 
14.-rwxrwSrwx 1 root root 38766042 2011-06-29 QQ2011Beta1.exe 
15.-rwxrwSrwx 1 root root 1161612562 01-17 09:57 Swd5.exe 
16.-rwxrwSrwx 1 root root 351354408 03-09 14:22 WindowsXP-KB936929-SP3-x86-CHS.exe 
17.-rwxrwSrwx 1 root root 350876489 03-09 15:53 WINDOWSXP-KB936929-SP3-X86-CHS.zi 
如果你需要每次系统启动都挂载这个目录，那就需要在fstab 文件里把需要挂载项添加进去 
    添加行： 
//200.120.75.24/share /windows cifs default,username=administrator,password=admin 0 2 
```

## 20. IP，子网划分如何计算 

```shell
掩码的算法：
11111111相当于从右边的第1个1开始算即从2的0次开始算起到2的7次
即11111111=2^0+2^1+2^2+2^3+2^4+2^5+2^6+2^7=1+2+4+8+16+32+64+128=255.
注意2的0次=1.
```

**20.1 某IP地址192.168.48.10，掩码为255.255.255.128，**

```shell
答：
netmask：11111111.11111111.11111111.10000000，
则第4段有2个1故2的1次方=2(如果有n个1则为2的n次方)接着把0-255共256个IP除以2即256÷2=128，
0~127
128~255
所以192.168.48.10在0~127即在192.168.48.0~192.168.48.127网段，
其所在的子网为192.168.48.0，广播地址为192.168.48.127，有效的主机IP地址范围从192.168.48.1到192.168.48.126.
```

**20.2 请写出10.0.0.128/26段中第一个地址和最后一个地址**

```shell
答：
netmask：11111111.11111111.11111111.11000000，
则第4段有2个1故2的2次方=4(如果有n个1则为2的n次方)接着把0-255共256个IP除以4即256÷4=64，
0~63
64~127
128~191
192~255
所以10.0.0.128在128~191即在10.0.0.128~10.0.0.191网段，
其所在的子网为10.0.0.128，广播地址为10.0.0.191，有效的主机IP地址范围从10.0.0.129到10.0.0.190.
```

如下图片是另外一种计算方法，直接几个零就是2的几次方，如有6个零就是2的6次=64那么一个网段64个ip，则

![424014012490591761](E:/daily/pic/424014012490591761.jpg)

## 21. WEB服务器架构

LNMP: Linux+Nginx+MySQL/MariaDB+PHP，代码放在WEB服务器Nginx的网站根目录，前端是Nginx服务器+中间是fcgi服务器+后端DB数据库服务器，

## 22. SSH安全连接
```shell
[kiosk@foundation41 Desktop]$ ssh root@172.25.41.10				#note:默认不写，22号端口。
[kiosk@foundation41 Desktop]$ ssh root@172.25.41.10 -p 22011	#note:22011端口
[kiosk@foundation41 Desktop]$ ssh root@172.25.41.9 -X			#note:图形化登录，界面不是图形化的，只是说可以使用或启动图形化程序如firefox.
```
## 23. 固态硬盘和传统硬盘
**固态硬盘和传统硬盘有什么区别，并说明它们的优点和缺点**
答：

优点：读写速度快，防震抗摔性强，低功耗，无噪音，工作温度范围大轻便；

 缺点：容量小，价格贵。数据恢复能力差。

## 24. 除Linux外的三种类Unix 

```shell
solaris, FreeBSD, AIX.
```

## 25. 32位和64位操作系统

**32位操作系统和64位操作系统的区别，并说明它们的优点和缺点**

答：优点：可以进行更大范围的整数运算；可以支持更大的内存。如支持更多的可寻址空间大于4GB。支持更大的虚拟内存16TB，支持更多的页面文件
512TB，支持更多的系统缓存1TB。支持更高的颜色质量（2的64次方）
缺点：缺点是向下兼容性差、支持硬件驱动较少。支持应用程序较少。需要硬件支持。

## 26. 前台作业和后台作业

创建后台作业在原有命令的基础后加上&              <--太平洋保险集团。
jobs //查看后台进程
fg //把相应的后台作业调到前台
ctrl+z //将前台的作业调到后台并暂停

例：ping 127.0.0.1 >> /tmp/file & //创建后台作业导出数据保存到/tmp/file文件中去
jobs //查看所有的后台进程
ctrl+z //停止调到前台的1号作业
bg 1 //重启1号作业
fg 1 //把1号后台作业调到前台
ctrl+c //停止作业

## 27. Docker容器

上海成思信息技术有限公司：

docker要求较高版本的Linux内核3.1以上故要装在rhel7版本，但也可以装在rhel6上面办法是**升级内核Kernel。**

## 28. 开启2000到5000连续端口

上海成思信息技术有限公司：

iptables -I INPUT -p tcp --dport 2000:5000 -j ACCEPT

## 29. 系统日志-->空间不足 

上海成思信息技术有限公司：

系统日志显示“no space left on the device”，但查看硬盘还有2TB的空间：可能是inode的问题，

```shell
No space left on device 看错误第反应磁盘空间满；df看每区空间都富余munin 监控图表看 Filesystem usage 平稳面 Inode usage 问题其区 usage 已经100%赶紧跑服务器df -i检查 Inode 耗尽原区用扔各种志临文件其某程序产临文件没进行定滚造磁盘空间耗尽前文件系统 Inode 用光 Linux/Unix like OS 文件系统每目录树节点并像 Windows 直接包含文件具体信息包含文件名 Inode number 通 Inode number 所找应于文件名 Inode 节点才真记录文件/物理址/所者/访问权限/间戳/硬链接数等实际metadata Linux 系统通硬链接( hard link ) 式给某文件创建数位于同目录文件名实际文件数据需要份拷贝 种文件系统结构 Linux 进行 IO 操作候需要资源除磁盘空间外要剩余 Inode 才行缺省情况 Linux 系统安装程按照1 Inode 应 2k 磁盘空间计算每区 Inode 数旦文件系统创建每区用 Inode 数进行态调整 说般太现某区 Inode 耗尽磁盘空间尚余情况除非像我碰垃圾文件疯没进行效清理确实需要创建文件系统（比用mke2fs）候根据实际需要调整参数（比区用于存放超视频文件 Inode 数量少些；打算存放文件量于 2k 迷文件要考虑创建些 Inode）取消息队列报错No space left on devicesysctl -w kernel.msgmni=128
东东MSGMNI --- 参数决定系统同运行message queue数root用sysctl kernel.msgmni检查该参数sysctl -w kernel.msgmni=XXX重新设定即

Linux inode已满解决方法
今天login server的一个网站，发现login后没有生成session。根据以往经验，一般是空间已满导致session文件生成失败。
[root@rhel6]# df -h  
Filesystem                    Size  Used Avail Use% Mounted on  
/dev/mapper/dev01-root         75G   58G   14G  82% /  
udev                          2.0G  4.0K  2.0G   1% /dev  
tmpfs                         396M  292K  396M   1% /run  
none                          5.0M     0  5.0M   0% /run/lock  
none                          2.0G  4.0K  2.0G   1% /run/shm  
/dev/sda1                     228M  149M   68M  69% /boot  
空间剩余14G，可以排除空间已满的情况。导致文件生成失败还有另一个原因，就是文件索引节点inode已满。
[root@rhel6]# df -i  
Filesystem                    Inodes   IUsed  IFree IUse% Mounted on  
/dev/mapper/dev01-root       4964352 4964352      0  100% /  
udev                          503779     440 503339    1% /dev  
tmpfs                         506183     353 505830    1% /run  
none                          506183       5 506178    1% /run/lock  
none                          506183       2 506181    1% /run/shm  
/dev/sda1                     124496     255 124241    1% /boot
inodes 占用100%，果然是这个问题。
解决方法：删除无用的临时文件，释放inode。
查找发现 /tmp 目录下有很多sess_xxxxx的 session临时文件。
[root@rhel6]# ls -lt /tmp | wc -l  
4011517
进入/tmp目录，执行find -exec命令
[root@rhel6]# sudo find /tmp -type f -exec rm {} \;  
如果使用rm *，有可能因为文件数量太多而出现Argument list too long错误，原因是在linux下，试图传太多参数给一个系统命令(ls *; cp *; rm *; cat *; etc..)时，就会出现 Argument list too long错误。
除了/tmp的临时文件外，0字节的文件也会占用inode，应该也释放。
遍历寻找0字节的文件，并删除。
[root@rhel6]# sudo find /home -type f -size 0 -exec rm {} \;
删除后，inode 的使用量减少为19%，可以正常使用了。
[root@rhel6]# df -i
Filesystem                    Inodes  IUsed   IFree IUse% Mounted on  
/dev/mapper/dev01-root       4964352 940835 4023517   19% /  
udev                          503779    440  503339    1% /dev  
tmpfs                         506183    353  505830    1% /run  
none                          506183      5  506178    1% /run/lock  
none                          506183      2  506181    1% /run/shm  
/dev/sda1                     124496    255  124241    1% /boot  
```

## 30. 进程ps aux, ps -ef 

进程
PID //进程ID
PPID //父进程ID
pstree //查看进程树

### 30.1 僵尸进程为Z

 上海成思信息技术有限公司：**ps aux的僵尸进程为Z，#note:这里是大写的Z，zombie**

### 30.2 ps -aux and ps -ef

ps aux 用BSD的格式来显示进程，显示的有USER , PID , %CPU , %MEM , VSZ , RSS , TTY , STAT , START , TIME , COMMAND；
ps -ef 用标准的格式显示进程，显示的有UID , PID , PPID , C , STIME , TTY , TIME , CMD。

**很多公司的笔试题中都有:** ps aux 中VSZ代表什么意思 RSS代表什么?  
VSZ 虚拟内存，该进程使用的虚拟内存量(KB)，虚拟内存集,进程占用的虚拟内存空间；
RSS 物理内存，该进程占用的固定内存量(KB)，物理内存集,进程战用实际物理内存空间.

```shell 
[root@localhost ~]# ps -aux |more      #note: 可以用 | 管道和 more 连接起来分页查看。
SUSE-LINUX:/ # ps -aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         29  0.0  0.0      0     0 ?        SN   15:10   0:00 [ksmd]
root         31  0.0  0.0      0     0 ?        S    15:10   0:00 [fsnotify_mark]
root         41  0.0  0.0      0     0 ?        S<   15:10   0:00 [kthrotld]
root        835  0.0  0.0   4440   380 tty1     Ss+  15:10   0:00 /sbin/agetty --noclear tty1 
root        849  0.0  0.0 337804   516 ?        Ssl  15:10   0:00 /usr/sbin/rsyslogd -n
root        949  0.0  0.4 194888  9572 tty7     Ssl+ 15:10   0:02 /usr/bin/Xorg :0
root       1018  0.0  0.0  28688   748 ?        SLs  15:10   0:00 /usr/sbin/wickedd-nanny
root       1456  0.0  0.0 232292  1508 ?        Sl   15:10   0:00 gdm-session-worker
root       1491  0.0  0.0 223552  1580 ?        Ssl  15:10   0:00 /usr/lib/upower/upowerd
rtkit      1514  0.0  0.0 174216   604 ?        SNsl 15:10   0:00 /usr/lib/rtkit/rtkit-daemon
root       1618  0.0  0.0  47092   968 ?        Ss   15:10   0:00 /usr/sbin/sshd -D
root       2906 36.3  0.0  25396  1444 pts/0    R+   16:26   0:00 ps -aux

静态查看进程，相当于为当前时间的进程创建一个快照，显示出来
ps aux //静态查看 a代表全部进程 u代表用户 x 代表没有控制终端的进程，就是开机启动时所运行的进程

ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
USER：创建进程的用户
PID:进程的ID号
%CPU：CPU的使用率，按百分比表示
%MEM：内存的使用率，按百分比表示
VSZ：虚拟内存使用数量，
RSS：物理内存使用数量
TTY:产生此进程的终端号
STAT：进程状态
START ：开始时间
TIME：运行时间
COMMAND：产生进程的命令或进程的名字
关于进程的状态
S：休眠状态
R：等待运行，（此进程处于运行或就绪的状态）
l：空闲状态
Z：僵尸状态
<:优先级较高
N：优先级较低
s：进程的领导者
+：在前台进程组

ps -ef //e代表全部的进程 f代表全格式罗列
UID PID PPID C STIME TTY TIME CMD
UID：创建进程的用户
PID:进程的ID号
PPID:父进程的ID号
C：CPU的占用率
STIME：开始的时间
TTY：产生此进程的终端号
TIME：运行的时间
CMD：产生进程的命令或进程的名字

ps -le //查看进程的优先级，主要关注 NI这一列，代表的是优先级

pgrep
-l 列出程序的名和进程ID
-u 列出该用户所产生的进程
-t 列出该终端号所产生的进程
例：pgrep -l ping //查看属于ping的进程，并显示进程名和PID
28365 ping
28418 ping
pgrep -u student //查看属于student用户的进程，只显示PID
28394
28418
pgrep -lu student //查看属于student用户的进程，显示PID和进程名
28394 bash
28418 ping
pgrep -t pts/1 //查看属于pts/1终端的进程，只显示PID
28201
28365

pidof 进程名 //只显示PID
```

### 30.3 top动态查看进程

````shell
动态进程
top 动态查看进程
h //查看帮助
d //输入刷新频率的秒数
按空格立即刷新
P //根据cpu的使用率进行排序
M //根据内存的使用率来进行排序
N //根据启动时间进行排序
n //提示输入显示的行数，进程数量
< //左翻页
> //右翻页
c //切换COMMAND的显示方式
k //代表kill结束进程，需要提供PID，默认使用15信号
ctrl+c来结束查看动态进程
````

### 30.4 kill结束进程

```shell
kill 命令的工作原理是，向Linux系统的内核发送一个系统操作信号和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。
kill 信号源 进程PID //来杀死相应的进程
信号源
	1：一个reload信号，重置信号，可以让服务重新加载自己的配置文件，让进程重新加载自己的信息包括配置文件。
	9：强制关闭某个进程
	15：等待程序正常退出信号。和9的区别在于数据流的回写。linux一般5分钟回写硬盘一次
pkill //根据条件来结束进程
-t //终端号
-u //用户名
例：pkill -9 -t pst/1 //杀死由终端号pst/1所产生的进程
pkill -9 -u student //杀死所有由用户student所产生的进程
killall 进程名 //用于杀死同名的所有进程
例：killall -9 ping //属于ping的进程将全部结束

命令格式 kill -3 pid
作用 打印进程号为pid的进程中，每个线程的执行日志 到 nohup文件 中，如果nohup的输出做了重定向，那么输出到重定向以后的文件中。
命令格式 top -Hp pid -d 1 -n 1 
作用 打印进程号为pid的进程个线程的cpu，内存等资源占用情况。
这2个命令组合使用可以找到 哪个进程的哪个线程 占用资源较多，从而定位资源占用高的问题所在。

kill -3 指令可以帮我们输出当前进程中所有线程的状态，如哪些线程在运行，哪些在等待，因为什么等待，代码哪一行等待，会将信息输出至控制台，被kill -3的进程最好是nohup启动的，并不会影响程序运行，不用担心他把程序杀死了。
kill -3 是SIGQUIT  Core  Quit from keyboard
kill -9 是SIGKILL  Term  Kill signal

[root@rhel7 ~]# kill -s 9 2934	#note: -s代表的是signal，9代表的第9个信号源，2934是进程的PID；
[root@rhel7 ~]# kill -9 2934	#note:上面的简写，省略-s；
[root@rhel7 ~]# xkill	#note:点谁谁死，如果没有此命令那么安装一下 yum -y install xkill，图形化界面的。
```

### 30.5 进程优先级nice

```shell
进程的优先级
ps -el 查看进程的优先级
优先级的范围：-20到19
数字越大，代表优先级越低
数字越小，代表优先级越高
注意：普通用户只能把优先级往低调节，root用户可以在范围内随意调节。
普通用户创建进程规定优先级时不能规定小于0的数字，root用户随意
1.创建该进程时指定优先级
nice -n 5 ping 127.0.0.1 //创建优先级为5的ping进程
2.修改现有进程的优先级
renice -n 10 PID号
例：renice -n 10 1868 //修改PID 1868进程的优先级为10
```

## 31. 七层网络协议

物理层 传输层 网络层 应用层 表示层 会话层 数据链路层
在OSI模型中，HTTP协议工作在第7层，交换机工作在第1-2层。(此题不够严谨，个人认为后面填2层，1-2层都不能算错）


在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手之后客户端与服务器开始传送数据.

## 32. TCP和UDP都有的协议

答：

    telnet (TCP)
    SMTP(TCP)
    DNS(tcp/udp)
    DNS一般使用UDP，DNS的主辅名字服务器在同步时使用TCP协议


## 33. web访问速度很慢

有一web服务器，某天某用户投诉上某个网站速度很慢，如果你是服务器的管理员，

请问：你如何查找原因。假设服务器有任意操作系统和软件。

    答：1、首先检测服务器状态，排除硬件故障和系统故障 排除机器故障
    2、检查底层网络状态（包括互联情况，PING包延迟、流量情况）排除网络故障和网卡等设备故障。
    3、检查WEB服务器软件运行情况（并发连接、服务软件配置情况、数据库连接情况等）排除应用服务故障。

## 34. shell 脚本中$0什么意思

上海极鲜网电子商务有限公司：

```shell
脚本举例
我们先写一个简单的脚本，执行以后再解释各个变量的意义
# touch variable
# vi variable
脚本内容如下：
#!/bin/sh
echo "number:$#"
echo "scname:$0"
echo "first :$1"
echo "second:$2"
echo "argume:$@"
保存退出
赋予脚本执行权限
# chmod +x variable
执行脚本
# ./variable aa bb
number:2
scname:./variable
first: aa
second:bb
argume:aa bb

结果分析

通过显示结果可以看到：
$# 是传给脚本的参数个数
$0 是脚本本身的名字
$1是传递给该shell脚本的第一个参数
$2是传递给该shell脚本的第二个参数
$@ 是传给脚本的所有参数的列表
```

## 35. DNS解析原理及TTL的含义

上海极鲜网电子商务有限公司，

```shell
首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。
DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。linux系统里面，DNS服务器的IP地址保存在/etc/resolv.conf文件。
上例的DNS服务器是192.168.1.253，这是一个内网地址。有一些公网的DNS服务器，也可以使用，其中最有名的就是Google的8.8.8.8和Level 3的4.2.2.2。
600是TTL值（Time to live 的缩写），表示缓存时间，即600秒之内不用重新查询。
```

## 36. keepalived所使用的协议

(上海极鲜网电子商务有限公司)

```shell
keepalived是什么
keepalived是集群管理中保证集群高可用的一个服务软件，其功能类似于heartbeat，用来防止单点故障。

keepalived工作原理
keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。
虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。

keepalived主要有三个模块，分别是core、check和vrrp。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。vrrp模块是来实现VRRP协议的。

keepalived的配置文件
keepalived只有一个配置文件keepalived.conf，里面主要包括以下几个配置区域，分别是global_defs、static_ipaddress、static_routes、vrrp_script、vrrp_instance和virtual_server。
```



linux操作系统没有回收站，删除的文件无法恢复，网络管理员为了防止误删文件，需要的配置是（）

```shell
alias rm= ‘rm-i’
或写个脚本如下，
首先，搞个回收站
在~下     .bashrc或者.bash_profile加入
[python] view plaincopyprint?
01.mkdir -p ~/.trash  
02.alias rm=trash    
03.alias r=trash    
04.alias rl='ls ~/.trash'  
05.alias ur=undelfile  
06.undelfile()  
07.{  
1. mv -i ~/.trash/$@ ./  
   09.}  
   10.trash()  
   11.{  
2. mv $@ ~/.trash/  
   13.}  

这是执行 
rm 就相当于执行mv了
注：此时已经木有 rm -rf了  
删除的文件会在.trash中出现
可以恢复回去
ur filename
这就带来一个问题，如何删除回收站里的东西，这是后rm在这里是木有用的
在刚才.bashrc下继续加函数
[python] view plaincopyprint?
01.cleartrash()  
02.{  
1. read -p "clear sure?[n]" confirm  
2. [ confirm == 'y' ] || [ confirm == 'Y' ]  && /usr/bin/rm -rf ~/.trash/*  
   05.}  
$. .bashrc 
然后，如果想清空回收站的话
$cleartrash就行了
1. 在/home/username/ 目录下新建一个目录，命名为：.trash
2.. 在/home/username/tools/目录下，新建一个shell文件，命名为： remove.sh
复制代码 代码如下:
PARA_CNT=$#
TRASH_DIR="/home/username/.trash"
for i in $*; do
STAMP=date +%s
fileName=basename $i
mv i TRASH_DIR/fileName.STAMP
done
1. 修改~/.bashrc， 增加一行
复制代码 代码如下:
alias rm="sh /home/username/tools/remove.sh"
用我们自建的remove.sh替代rm命令
1. 设置crontab，定期清空垃圾箱，如：
复制代码 代码如下:
0 0 * * * rm -rf /home/username/.trash/*
每天0点清空垃圾箱
1. source ~/.bashrc 使替换立即生效
经过上面的步骤后，执行rm删除的文件，会被放入垃圾箱。如果误删除，可以从中恢复。
```

查看系统tcp连接中各个状态的连接数/查看web的并发请求数及其TCP连接状态

查看Apache的并发请求数及其TCP的连接状态
```shell
netstat -n | awk '/^tcp/ {++b[$NF]} END {for(a in b) print a, b[a]}' 
netstat -an | awk '/^tcp/{s[$NF]++}END{for (a in s)print a,s[a]}'
netstat -nt | awk '{++S[$NF]}END{for(a in S) print a,S[a]}'
或# netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
netstat -nat |awk '{print $6}'|sort|uniq -c|sort -rn
netstat -n | awk '/^tcp/ {++state[$NF]}; END {for(key in state) print key,"\t",state[key]}'
netstat -n | awk '/^tcp/ {++arr[$NF]};END {for(k in arr) print k,"\t",arr[k]}'
netstat -n |awk '/^tcp/ {print $NF}'|sort|uniq -c|sort -rn
netstat -ant | awk '{print $NF}' | grep -v '[a-z]' | sort | uniq -c
```

还有ulimit -n 查看linux系统打开最大的文件描述符，这里默认1024，不修改这里web服务器修改再大也没用。若要用就修改很几个办法，这里说其中一个：

修改/etc/security/limits.conf
* soft nofile 10240
* hard nofile 10240


统计80端口的连接数据

netstat -nat | grep -i "80" | wc -l

统计httpd协议连接数
ps -ef | grep httpd | wc -l

统计已连接的，状态为establish的
netstat -na | greo ESTABLISH | wc -l

查出那个IP连接最多，并将其封掉

```shell
netstat -na | grep ESTABLISH | awk {print 5} | awk -F:{print 1}| sort | uniq -c | sort -r +On
```

查看apache当前并发访问数
netstat -na | grep ESTABLIS | wc -l

查看有多少个进程数
ps -aux | grep httpd | wc -l

SYN_RECV表示正在等待处理的请求数；ESTABLISHED表示正常数据传输状态；TIME_WAIT表示处理完毕，等待超时结束的请求数。
　　状态：描述

　　CLOSED：无连接是活动 的或正在进行

　　LISTEN：服务器在等待进入呼叫

　　SYN_RECV：一个连接请求已经到达，等待确认

　　SYN_SENT：应用已经开始，打开一个连接

　　ESTABLISHED：正常数据传输状态

　　FIN_WAIT1：应用说它已经完成

　　FIN_WAIT2：另一边已同意释放

　　ITMED_WAIT：等待所有分组死掉

　　CLOSING：两边同时尝试关闭

　　TIME_WAIT：另一边已初始化一个释放

　　LAST_ACK：等待所有分组死掉

用tcpdump嗅探80端口的访问看看谁最高
tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F"." '{print $1"."$2"."$3"."$4}' | sort | uniq -c | sort -nr |head -20
tcpdump -i eth0 -tnn dst port 80 -c 100 | awk -F"." '{print $1"."$2"."$3"."$4}' | sort | uniq -c | sort -nr
tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F"." '{print $1"."$2"."$3"."$4}' | sort | uniq -c | sort -nr |head -5&nbsp; 


-i	参数指定tcpdump监听的网络界面，选择过滤的网络接口，如果是作为路由器至少有两个网络接口而这个选项只过滤指定的接口上通过的数据，例如tcpdump -i eth0只显示通过eth0接口上的所有报头；
-c	参数指定要监听的数据包数量，
-w	参数指定将监听到的数据包写入文件中保存
-i 
-t 在输出的每一行不打印时间戳
-nn 不进行端口名称的转换。
dst 目的地
port 80  80端口


Tcpdum是Linux上强大的网络数据采集分析工具,总的的输出格式为：系统时间 来源主机.端口 > 目标主机.端口 数据包参数
        1.1 第一种类型的关键字：host    net     port        
            host 210.27.48.3指明 210.27.48.3是一台主机       net202.0.0.0 指明202.0.0.0 是一个网络地址   port 23 指明端口23
        1.2 第二种确定传输方向的关键字，主要包括 src,dst，dst or src，dst and src。这些关键字指明了传输的方向。
             src 源；        dst 目的；         没有指明方向关键字，则缺省是src or dst.
    
        1.3 第三种是协议的关键字，主要包括ip,arp，udp,tcp,fddi


统计/var/log/下文件个数 
ls /var/log/ | wc -l 
ls /var/log/ -lR| grep "^-" |wc -l 
find /var/log -maxdepth 1 -mindepth 1 -type f | wc -l

查看当前系统每IP连接数

```shell
netstat -an | awk -F"[ :]+" '{s[$6]++}END{for (a in s) print s[a],a}' | sort -nr | head 

netstat -an | awk '/^tcp/{print 5}' | awk -F : '{print 1}' | sort | uniq -c | sort -nr

netstat -n | awk '/^tcp/ {print 5}'| awk -F: '{print 1}' | sort | uniq -c | sort -rn
```


shell下32位随机密码生成
head /dev/urandom | md5sum | head -c 30 
cat /dev/urandom | head -1 | md5sum | head -c 32 >> /pass  #note:并将生成的32位随机数 保存到/pass文件里。


统计出apache的access.log中访问量最多的5个IP 
awk '{s[$1]++}END{for (a in s)print a,s[a]}' access.log | sort -nr 
cat access_log | awk  '{print $1}' | sort | uniq -c | sort -n -r | head -5 

linux如何查看二进制文件的内容
查看二进制文件，用od或hexdump命令。

$ od -tx1 -tc -Ax binFile 
000000  61  62  63  64  65  31  32  33  34  35  61  62  63  64  65  31 
         a   b   c   d   e   1   2   3   4   5   a   b   c   d   e   1 
000010  32  33  34  35  61  62  63  64  65  31  32  33  34  35  61  62 
         2   3   4   5   a   b   c   d   e   1   2   3   4   5   a   b 
000020  63  64  65  31  32  33  34  35  0a 
         c   d   e   1   2   3   4   5  \n 
000029  
-tx1选项表示将文件中的字节以十六进制的形式列出来，每组一个字节（类似hexdump的-c选项）
-tc选项表示将文件中的ASCII码以字符形式列出来（和hexdump类似，输出结果最左边的一列是文件中的地址，默认以八进制显示）
-Ax选项要求以十六进制显示文件中的地址


hexdump命令一般用来查看”二进制“文件的十六进制编码，但实际上它的用途不止如此，手册页上的说法是“ascii, decimal, hexadecimal, octal dump“，这也就是本文标题为什么要将”十六“给引起来的原因，而且它能查看任何文件，而不只限于二进制文件了。我们一般通过hexdump命令 来查看二进制文件的内容。

hexdump -C XXX(文件名)  -C是参数 不同的参数有不同的意义

-C  是比较规范的 十六进制和ASCII码显示

-c  是单字节字符显示

-b  单字节八进制显示

-o  是双字节八进制显示

-d  是双字节十进制显示

-x  是双字节十六进制显示

如果要看到较理想的结果，使用-C参数，显示结果分为三列（文件偏移量、字节的十六进制、ASCII字符）。
格式：hexdump -C binfile
-C 输出规范的十六进制和ASCII码。来自: [http://man.linuxde.net/hexdump]
一般文件都不是太小，最好用less来配合一下。
格式：hexdump -C binfile | less

[root@new55~]# echo /etc/passwd | hexdump -C   #note:规范的十六进制和ASCII码显示（Canonical hex+ASCII display ）

linux 检测并修复/dev/hda5 
fsck用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查
fsck -a /dev/hda5 
[root@localhost ~]# fsck -C -t ext3 /dev/sda5
命令：fsck
　　参数 ：
　　
　　filesys ： device 名称(eg./dev/sda1)，mount 点 (eg. / 或 /usr)
　　-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数
　　-s : 依序一个一个地执行 fsck 的指令来检查
　　-A : 对/etc/fstab 中所有列出来的 partition 做检查
　　-C : 显示完整的检查进度
　　-d : 列印 e2fsck 的 debug 结果
　　-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行
　　-R : 同时有 -A 条件时，省略 / 不检查
　　-V : 详细显示模式
　　
　　-a : 如果检查有错则自动修复
　　-r : 如果检查有错则由使用者回答是否修复

        补充说明：

　　例子 :
　　检查 msdos 档案系统的 /dev/hda5 是否正常，如果有异常便自动修复 :
　　 fsck -t msdos -a /dev/hda5

Linux开机启动顺序 十个步骤：
加载BIOS–>读取MBR–>Boot Loader–>加载内核–>用户层init一句inittab文件来设定系统运行的等级(一般3或者5，3是多用户命令行，5是界面)–>init进程执行rc.syninit–>启动内核模块–>执行不同级别运行的脚本程序–>执行/etc/rc.d/rc.local(本地运行服务)–>执行/bin/login,就可以登录了。


启动第一步－－加载BIOS
当你打开计算机电源，计算机会首先加载BIOS信息，BIOS信息是如此的重要，以至于计算机必须在最开始就找到它。这是因为BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，计算机心里就有谱了，知道应该去读取哪个硬件设备了。

启动第二步－－读取MBR
众所周知，硬盘上第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即主引导记录，它的大小是512字节，别看地方不大，可里面却存放了预启动信息、分区表信息。
系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0×7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader，而具体到你的电脑，那就是lilo或者grub了。

启动第三步－－Boot Loader
Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。
Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。
我们以Grub为例来讲解吧，毕竟用lilo和spfdisk的人并不多。
系统读取内存中的grub配置信息（一般为menu.lst或grub.lst），并依照此配置信息来启动不同的操作系统。

启动第四步－－加载内核
根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。此时，屏幕一般会输出“Uncompressing Linux”的提示。当解压缩内核完成后，屏幕输出“OK, booting the kernel”。
系统将解压后的内核放置在内存之中，并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。

启动第五步－－用户层init依据inittab文件来设定运行等级
内核被加载后，第一个运行的程序便是/sbin/init，该文件会读取/etc/inittab文件，并依据此文件来进行初始化工作。
其实/etc/inittab文件最主要的作用就是设定Linux的运行等级，其设定形式是“：id:5:initdefault:”，这就表明Linux需要运行在等级5上。Linux的运行等级设定如下：
0：关机
1：单用户模式
2：无网络支持的多用户模式
3：有网络支持的多用户模式
4：保留，未使用
5：有网络支持有X-Window支持的多用户模式
6：重新引导系统，即重启
关于/etc/inittab文件的学问，其实还有很多

启动第六步－－init进程执行rc.sysinit
在设定了运行等级后，Linux系统执行的第一个用户层文件就是/etc/rc.d/rc.sysinit脚本程序，它做的工作非常多，包括设定PATH、设定网络配置（/etc/sysconfig/network）、启动swap分区、设定/proc等等。如果你有兴趣，可以到/etc/rc.d中查看一下rc.sysinit文件，里面的脚本够你看几天的

启动第七步－－启动内核模块
具体是依据/etc/modules.conf文件或/etc/modules.d目录下的文件来装载内核模块。

启动第八步－－执行不同运行级别的脚本程序
根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。

　　启动第九步--执行/etc/rc.d/rc.local

　　你如果打开了此文件，里面有一句话，读过之后，你就会对此命令的作用一目了然：

```shell
This script will be executed after all the other init scripts.

You can put your own initialization stuff in here if you don’t

want to do the full Sys V style init stuff.
```



　　rc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。你可以把你想设置和启动的东西放到这里。

　　启动第十步--执行/bin/login程序，进入登录状态

　　此时，系统已经进入到了等待用户输入username和password的时候了，你已经可以用自己的帐号登入系统了。
　1: 启动电源后，主机第一步先做的就是查询BIOS(全称：basic input/output system 基本输入输出系统)信息。了解整个系统的硬件状态，如CPU，内存，显卡，网卡等。嗯，这一步windows算和它是一家。不分彼此。

　　2: 接下来，就是主机读取MBR(硬盘的第一个扇区)里的boot loader了。这个可是重点哦，据说troubleshooting里就会考这点，给个坏了的loader，叫你修正。windows不支持linux的分区格式。所以，用windows的boot。ini是查不到linux的系统的。一般我装系统都是先装 windows再装linux，然后用grub来做boot loader。两个字：省心!因为linux不像windows那么小气。grub可是支持windows分区格式的哦。

　　3: 接上一步，主机读取boot loader后，会读取里面的信息，知道谁跟谁是待在哪，假如主机想进入linux系统，读取到linux核心是在/boot文件目录中后，将此核心加载到内存中。开始了接下来的分析启动之旅。

　　4: OK，第一个运行程序是谁？就是/sbin/init程序。不信，就用top程序看下，是不是PID为1的就是这个东东，它，可是万物之祖啊，我简称它是女娲娘娘(不喜欢亚当夏娃)。

　　· 5: init首先查找启动等级(run-level)。因为启动等级不同，其运行脚本(也就是服务)会不同。默认的等级有以下几项：

　　0 - halt (系统直接关机)

　　1 - single user mode (单人模式，用于系统维护时使用)

　　2 - Multi-user， without NFS (类似3模式，不过少了NFS服务)

　　3 - Full multi-user mode (完整模式，不过，是文本模式)

　　4 - unused (系统保留功能)

　　5 - X11 (与3模式类似，不过，是X终端显示)

　　6 - reboot (重新开机)

　　(不要选择0或4，6 否则，进步了系统的)

　　· 6: OK。系统知道自己的启动等级后，接下来，不是去启动服务，而是，先设置好主机运行环境。读取的文件是/etc/rc。d/rc。sysinit文件。那究竟要设置哪些环境呢？

　　· 设置网络环境/etc/sysconfig/network，如主机名，网关，IP，DNS等。

　　· 挂载/proc。此文件是个特殊文件，大小为0，因为它是在内存当中。里面东东最好别删。

　　· 根据内核在开机时的结果/proc/sys/kernel/modprobe。开始进行周边设备的侦测。

　　· 载入用户自定义的模块/etc/sysconfig/modules/*。modules

　　· 读取/etc/sysctl。conf文件对内核进行设定。

　　· 设定时间，终端字体，硬盘LVM或RAID功能，以fsck进行磁盘检测。

　　· 将开机状况记录到/var/log/dmesg中。(可以用命令dmesg查看结果)

　　· 7: OK，接下来，就是启动系统服务了，不同的run-level会有不同的服务启动。到/etc/rc。d目录中，不同的level会有不同的目录。如启动 3模式，会有个rc3。d目录，里面就保存着服务。其中，S(start)开头的表明开机启动，K(kill)开头的表明开机不启动。数字表示启动顺序。数字越小，启动越早。

　　注意，他们都是连接到etc/rc。d/init。d/目录中的相关文件。所以，想手工启动某一服务，可以用"/etc/rc。d/init。 d/某个服务 start"启动哦。相反，我们也可以把某个服务ln(链接命令)到不同run-level的目录中。记得打上S或者K+数字哦。

　　· 8: 读取服务后，主机会读取/etc/rc。d/rc。local文件。所以，如果需要什么开机启动的话，可以写个脚本或命令到这里面来。就不用像上面那么麻烦。以后删除也方便。

Linux符号链接和硬链接的区别

硬链接 就好像是 又复制了一份.
ln 3.txt 4.txt   这是硬链接，相当于复制，不可以跨分区，但修改3,4会跟着变，若删除3,4不受任何影响。
ln -s 3.txt 4.txt  这是软连接，相当于快捷方式。修改4,3也会跟着变，若删除3,4就坏掉了。不可以用了。

硬链接通过索引节点来进行连接，
符号链接即软链接类似于windows的快捷方式，实际是一个特殊的文件。

使用“date -s”命令来修改系统时间
比如将系统时间设定成1996年6月10日的命令如下。
```shell
date -s 06/10/96
```



将系统时间设定成下午1点12分0秒的命令如下。
```shell
date -s 13:12:00
```

写一个脚本，实现判断192.168.1.0/24网络里，当前在线的IP有哪些，能ping通则认为在线

```shell
!/bin/bash
for i in {1..254};do if ping -c 192.168.1.$i
then 
echo 192.168.1$i >> ip_live.txt
fi
done
```

Linux保存当前磁盘分区的分区表
dd if=/dev/sda of=./mbr.txt bs=1 count=512 
dd if=/dev/sda of=/backup/mbr.bak count=1 bs=512 
sfdisk -d /dev/sdb >/etc/sdbpar.bak 保存分区表 # sfdisk /dev/sdb 
fdisk w

Linux 手动安装grub
在root用户下：grub-install [OPTION] install_device 
```shell
grub-install --root-directory=(指定boot目录) DEVICE
```

或者   grub   grub>root (hd0,0)   grub>setup (hd0)
用linux的光盘启动后进入rescue模式
启动grub命令
root (hdX,Y)
setup (hdX)

X是你的linux在第几个硬盘　大多数情况为0
Y是你的linux在硬盘的第几个分区
都是从0开始

在1-39内取随机数
echo $[$RANDOM%39]
expr $[$RANDOM%39] + 1 
RANDOM 随机数，%39 取余数 范围 0-38



修改内核参数
vi /etc/sysctl.conf  这里修改参数
sysctl -p  刷新后可用



限定apache每秒钟连接数为1,峰值为3 
每秒新建连接数 一般都是由防火墙来做，apache本身好像无法设置每秒新建连接数，只能设置最大连接：

iptables -A INPUT -d 172.16.100.1 -p tcp --dport 80 -m limit --limit 1/second  -j ACCEPT 

显示/etc/inittab中以#开头，且后面跟了一个或者多个空白字符，而后又跟了任意非空白字符的行
grep "^# \{1,\}[^ ]" /etc/inittab 

显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行
grep "\:[0-9]\{1\}\:" /etc/inittab 

怎么把脚本添加到系统服务里，即用service来调用


```shell
[root@localhost tmp]# cat test 
#!/bin/bash
chkconfig: 345 85 15
description: test
restart() { 
/etc/init.d/httpd restart 
} 
case "$1" in 
restart) 
restart 
;; 
*) 
echo "Usage: 0 {restart}" 
esac
[root@localhost tmp]# chmod u+x test 
[root@localhost tmp]# cp -a test /etc/init.d/ 
[root@localhost tmp]# chkconfig --add test 
[root@localhost tmp]# chkconfig --list | grep test 
test 0:off 1:off 2:off 3:on 4:on 5:on 6:off 
[root@localhost tmp]# service test restart 
Stopping httpd: [ OK ] 
Starting httpd: [ OK ] 
```

写一个脚本，实现批量添加20个用户，用户名为user01-20，密码为user后面跟5个随机字符
```shell
#!/bin/bash

description: useradd

for i in seq -f"%02g" 1 20;do

useradd user$i

echo "useri-`echo RANDOM|md5sum|cut -c 1-5`"|passwd –stdinuser$i >/dev/null 2>&1

done 

[root@localhost tmp]# cat Useradd.sh 

!/bin/bash

description: useradd

for i in seq 1 20 

do 

pwd=$(cat /dev/urandom | head -1 | md5sum | head -c 5) 

useradd user$i 

echo "useripwd" | passwd --stdin user$i 

echo useri useri$pwd" >> userinfo.txt 

done 

```




写一个脚本，实现判断192.168.1.0/24网络里，当前在线的IP有哪些，能ping通则认为在线
```shell
#!/bin/bash

for ip in seq 1 255

  do

    {
     ping -c 1 192.168.1.$ip > /dev/null 2>&1
     if [ $? -eq 0 ]; then
          echo 192.168.1.$ip UP
     else
          echo 192.168.1.$ip DOWN
     fi

   }&

done

wait 

```



写一个脚本，判断一个指定的脚本是否是语法错误；如果有错误，则提醒用户键入Q或者q无视错误并退出其它任何键可以通过vim打开这个指定的脚本

```shell
[root@localhost  tmp]# cat checksh.sh

!/bin/bash

read -p "please input check script-> " file

if [ -f $file ]; then

    sh -n $file > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        read -p "You input $file syntax error,[Type q to exit or Type vim to  edit]" answer
        case $answer in
        q | Q)
           exit 0
           ;;
        vim )
           vim $file
           ;;
        *）
         exit 0
         ;;
        esac

   fi

else

    echo "$file not exist"
    exit 1

fi 

```



MySQL备份命令？MySQL最新版本如何给root用户对mso授权访问，密码mso.china，请写出命令？
mysqldump
grant all on *.* to mso identified by mso.china;

Jekins+Gitlab协作需要哪些插件？


26、写一个脚本：(26包括3个小题)
1、创建一个函数，能接受两个参数：

1)第一个参数为URL，即可下载的文件；第二个参数为目录，即下载后保存的位置；

2)如果用户给的目录不存在，则提示用户是否创建；如果创建就继续执行，否则，函数返回一个51的错误值给调用脚本；

3)如果给的目录存在，则下载文件；下载命令执行结束后测试文件下载成功与否；如果成功，则返回0给调用脚本，否则，返回52给调用脚本；

```shell
[root@localhost tmp]# cat downfile.sh

!/bin/bash

url=$1

dir=$2

download()

  {

    cd $dir >> /dev/null 2>&1
    if [ $? -ne 0 ];then
        read -p "$dir No such file or directory,create?(y/n)" answer
        if [ "$answer" == "y" ];then
            mkdir -p $dir
            cd $dir
            wget $url 1> /dev/null 2>&1
        else
            return "51"
        fi
    fi
    if [ $? -ne 0 ]; then
        return "52"
    fi

}

download url dir

echo $? 
```


请使用命令查出Linux系统下哪个进程占用12345端口。
lsof -i:12345

请写出如何查看系统的iops指标。
iostat  tps 列 及为iops值
Linux服务器上的resign进程卡死(进程中包含java和resign_xxx信息)，请写下手工杀掉此进程的操作步骤或命令，以及为什么？
ps aux | grep Java | awk '{ print $2 }' | xargs -I {} kill -9 {}
请简写一个Python擅长做的事情。
python 是同时支持脚本的一种[编程语言](https://m.baidu.com/s?word=%B1%E0%B3%CC%D3%EF%D1%D4&from=1018914a&lqsource=-1&dmaseid=dmaseid0&qid=000000005288d19d)。十分强大！不像c++/java那样的高级语言，需要编译成字节码之后才能运行，python可以边运行边解释。python 主要应用于以下几个领域：

web开发，基于python产生了许多优秀的web框架，像django[[https://www.djangoproject.com/](https://www.djangoproject.com/)]，web.py[[http://baike.baidu.com/view/5493106.htm?fr=aladdin](http://baike.baidu.com/view/5493106.htm?fr=aladdin)]，许许多多伟大的开源社区的程序员为它们贡献了诸多的开源库，使得开发起来十分便捷。

爬虫开发，实际上这个只是一个小小的应用，基于python的http库有很多，比如常见的httplib，urllib2，requests等， 都很好的封装了http协议中的post,get等方法，也很方便的能够模拟浏览器去实现自己想要的功能，并且，对网页的解析也有诸多工具可以使用，如beautifulsoup等。

科学计算，不得不提的是python在科学计算领域也应用越来越广，如物理学领域，各种实验数据的处理以及相关实验模拟等，机器学习领域也产生了诸多的开源库，如sklearn，里面集成了机器学习领域常见的算法，接口良好，文档丰富，也有最近十分火热的Deep Learning的开源库，如theano。

高性能服务器后端，高性能不是说python执行有多快，其实python还是比较慢的，但是在开发高并发，高吞吐率的服务器的时候，还是具有自己独特的优势。

还有一切边边角角的应用，比如开发界面程序，QT也提供了python的支持，因为python的开源库中包括了对c/c++ lib库的调用。


python特性挂平台 擅长处理数据 做数据分析，跨平台。
需要抓取eht2网卡上从10.0.0.33发到本机8080端口的数据包，请列举你能想到的工具或方法，并给出一个具体方法的实现(详细命令或者代码)。

请写出如何针对2000个OS进行统一操作，需保证正确和完整执行。

## 37. MySQL数据库

**作为一个很重要的MySQL数据库，你觉得应该拿出怎样的备份机制才能在数据库服务器异常时将损失降到最低？并说出你的理由**

答：1. 定期进行全备份；2. 定期进行增量备份。将数据库风险降到最低。一周1全备，每天或每隔一天增备。

**请列出任意三个数据库的维护命令，如MySQL备份，查看sql进程，查看琐情况或其他**

```shell
#授权grant:
grant select on *.* to stu@'172.25.%' identified by 'uplooking';
*.* 表示所有数据库的所有表，前面一个是数据库+后面是一个是表，如果你要授权个某个数据库的所有表就修改为：db.*
```

```shell
#数据量不是很大，我准备直接用mysqldump准备，以后数据量大了，用innodbackup吧
#mysql5.5之后，默认都innodb了，不用关心myisam的事；

分 MYISAM 和 INNODB 引擎两种备份方式：

数据一致 服务可用性
MYISAM ok no --lock-all-tables 温备
INNODB ok ok --single-transaction 在线热备

	# MYISAM 可以保存所有包括 myisam,innodb 的数据库但只能保证 myisam 数据的完整性，无
法保证 innodb 数据库的完整性。
mysqldump -uroot -puploooking [需要备份的数据库] --lock-all-tables > /tmp/mysql.sql
[需要备份的数据库] -A 所有的数据库
-B db1， db2， db3
jishigou
mysqldump -uroot -puplooking123 -A --lock-all-tables > /tmp/mysql02.sql #保存所有数据库
mysqldump -uroot -puplooking123 -B db1, db2, db3 --lock-all-tables > /tmp/mysql02.sql #保存 db1,db2, db3共3个数据库
mysqldump -uroot -puplooking123 jishigou --lock-all-tables > /tmp/mysql02.sql #保存 jishigou 数据
库,注意不是-jishigou 没有-


	#INNODB 可以保存所有包括 myisam,innodb 的数据库但只能保证 innodb 数据的完整性，无法保
证 myisam 数据库的完整性。
mysqldump -uroot -puplooking123 -A --single-transaction > /tmp/mysql02.sql
```



**请简述你对MySQL数据库性能优化的解决思路**

1、调整数据结构的设计。这一部分在开发信息系统之前完成，程序员需要考虑是否使用ORACLE数据库的分区功能，对于经常访问的数据库表是否需要建立索引等。

2、调整应用程序结构设计。这一部分也是在开发信息系统之前完成，程序员在这一步需要考虑应用程序使用什么样的体系结构，是使用传统的Client/Server两层体系结构，还是使用Browser/Web/Database的三层体系结构。不同的应用程序体系结构要求的数据库资源是不同的。

3、调整数据库SQL语句。应用程序的执行最终将归结为数据库中的SQL语句执行，因此SQL语句的执行效率最终决定了ORACLE数据库的性能。ORACLE公司推荐使用ORACLE语句优化器（Oracle Optimizer）和行锁管理器（row-level manager）来调整优化SQL语句。
4、调整服务器内存分配。内存分配是在信息系统运行过程中优化配置的，数据库管理员可以根据数据库运行状况调整数据库系统全局区（SGA区）的数据缓冲区、日志缓冲区和共享池的大小；还可以调整程序全局区（PGA区）的大小。需要注意的是，SGA区不是越大越好，SGA区过大会占用操作系统使用的内存而引起虚拟内存的页面交换，这样反而会降低系统。

5、调整硬盘I/O，这一步是在信息系统开发之前完成的。数据库管理员可以将组成同一个表空间的数据文件放在不同的硬盘上，做到硬盘之间I/O负载均衡。

6、调整操作系统参数，例如：运行在UNIX操作系统上的ORACLE数据库，可以调整UNIX数据缓冲池的大小，每个进程所能使用的内存大小等参数。
请MySQL简述binlog的作用及其开关影响。
定义

二进制日志包含了所有更新了数据或者已经潜在更新了数据（例如，没有匹配任何行的一个DELETE）的所有语句。
my.cnf配置 binlog相关参数

设置此参数表示启用binlog功能，并制定二进制日志的存储目录， log-bin=/home/mysql/binlog/mysql-bin  #mysql-bin.*日志文件最大字节（单位：字节） #设置最大100MB max_binlog_size=104857600  #设置了只保留7天BINLOG（单位：天） expire_logs_days = 7  #binlog日志只记录指定库的更新 #binlog-do-db=db_name  #binlog日志不记录指定库的更新 #binlog-ignore-db=db_name

NOTE:
max_binlog_size — Binlog最大和默认值是1GB，该设置并不能严格控制Binlog的大小，尤其是Binlog比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的所有SQL都记录进当前日志，直到事务结束。所以真实文件有时候会大于max_binlog_size设定值！
expire_logs_days — binlog过期删除不是服务定时执行，是需要借助事件触发才执行，事件有a.服务器重启 b.服务器被更新 c.日志达到了最大日志长度max_binlog_size d.日志被刷新mysql> flush logs;

作用

二进制日志的主要目的是在恢复使能够最大可能地更新数据库，因为二进制日志包含备份后进行的所有更新。
二进制日志还用于在主服务器上记录所有将发送给从服务器的语句。
不良影响：运行服务器时若启用二进制日志则性能大约慢1%。
基础知识
二进制日志的启用
二进制日志由配置文件的log-bin选项负责启用，Mysql服务器将在数据根目录创建两个新文件XXX-bin.001和XXX-bin.index，若配置选项没有给出文件名，Mysql将使用主机名称命名这两个文件，其中.index文件包含一份全体日志文件的清单。

MySQL数据库运行一段时间后可能需要做哪些维护？
在MySQL使用的过程中，在系统运行一段时间后，可能会产生碎片，造成空间的浪费，所以有必要定期的对MySQL进行碎片整理。

请列举你所知道的监控系统，并简述每个系统的优点和缺点

请描述大型互联网运维工作的难度在哪里，以及如何解决。



## 38. 运维工程师技能和品质

**Linux运维工程师都需要具备哪些技能和职业品质？你认为一个出色的游戏运营维护工程师必须具备的关键素质有哪些？并按从主到次的顺序解释。**

    答：1、主动乐观、积极的态度
    2、细心和抗压力
    3、丰富的知识面和超强的沟通能力
    4、时刻冷静的头脑
    5、正直 
## 39 Oracle数据库

### 39.1 DG

```shell
ORACLE DG的三种模式是什么：
　　– Maximum protection	最大保护
　　– Maximum availability	最高可用性
　　– Maximum performance	最高性能
 
DG是dataguard，也叫standby，是oracle提供的一种容灾解决方案，只有企业版可用，标准版是不能用的，DG最多可以有一个主节点，9个从节点。可分为逻辑和物理两类，这里注意区分一下，逻辑的是通过redo转换成SQL语句，然后再standby上执行该SQL语句实现的同步，物理standby是接受主节点的redo数据后，以介质恢复的方式进行同步，这是这两者的本质区别。
 
#DG的三种模式：
最大保护：主节点事务提交前，redo写入在线日志，而且从节点也要写入到standby redolog中，并且保证在从库中至少一个节点可用，在主节点才提交事务，注意，最大保护模式，从节点故障，主库会被shutdown。在Maximum protection下， 可以保证从库和主库数据完全一样，做到zero data loss.事务同时在主从两边提交完成，才算事务完成。如果从库宕机或者网络出现问题，主从库不能通讯，主库也立即宕机。在这种方式下，具有最高的保护等级。但是这种模式对主库性能影响很大，要求高速的网络连接。
 
最高性能：这种模式，主节点随时提交事务，事务提交时，redo至少写入一个从节点，但是写入不一定同步。在Maximum performance，主库把归档的 archived log通过arch进程传递给从库，在这种方式下，主库运行性能最高，但是不能保证数据不丢失，且丢失的数据受redo log的大小影响。在redo log过大的情况下，可能一天都没有归档一个日志，可以通过手工切换日志的方式来减小数据的丢失。
 
最高可用性：这种模式和最大保护有点类似，不同的是，从库故障，主库不会shutdown,而是转为最高性能模式，从库恢复后，转回最高可用性模式。在Maximum availability模式下，如果和从库的连接正常，运行方式等同Maximum protection模式，事务也是主从库同时提交。如果从库和主库失去联系，则主库自动切换到Maximum performance模式下运行，保证主库具有最大的可用性。

#大家在做dataguard database 的时候一般选择什么样的模式：目前国内基本上是最大性能模式。
```

### 39.2 监控项

```shell
要看用什么工具这是一说，另外一个要看是什么类型的数据库，是OLTP还是OLAP
联机事务处理OLTP（on-line transaction processing）联机分析处理OLAP（On-Line Analytical Processing）
重要的指标一般都是SQL的执行时间的长短，表空间使用率啊，有没有锁表啊，数据库的性能啊，可以打开oracle的EM图形界面看看。
```

## 40. sudo

```shell
普通用户要使用sudo命令执行root的权限，
首先要在root下编辑/etc/sudoers文件，在第98行的下面添加一行： student ALL=(ALL)  ALL
[root@rhel6 ~]# sed -n '98,99p' /etc/sudoers
root	ALL=(ALL) 	ALL
student	ALL=(ALL) 	ALL
```

## 41. 权限r w x s t i a

```shell
-rwxr-xr-x  0755 其中-是0，rwx分别是421；
r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录内的文件(或目录)的权限而如果没有r权限，即使有wx的权限能进入这个目录但也无法看到这个目录内的任何文件或目录。

w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。
从大的方面讲，删除权限是w，但一定要注意，一个用户是否具体删除此文件或目录的权限要看它的上一级目录针对此用户是否有w的权限-->如果上级目录对此用户有w权限则即使此用户对此文件或文件的权限为000则也可删除此文件或目录，而如果没有则即使此用户对此文件或目录有w权限或777权限但也是无法删除此文件。

x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。没有x权限根本就无法进入该目录则即使有对此目录的rw读写权限也是无法读写目录内的文件因为根本首先就进不去。
```

```shell
Linux中的 s权限 t权限 i权限 a权限

0755最前面的0表示不使用任何特殊权限，该位上的数字可以是0,1(--t),2(-s-),3(-st),4(s--),5(s-t),6(ss-),7(sst)

#s和t是针对执行权限来讲的.
# s root执行
s是针对执行权限来讲的，必须要先有x执行权限，s才有效。
s权限只能使用在二进制文件上，小写s表示生效，大写S表示失效；s权限是'使用root用户执行'的权限。在这里使用 chmod +s filename 和 chmod -s filename 来更改文件的s权限。如果用户本身没有文件的x权限，就直接加上了s权限就会导致s权限位失效，显示为大写S。

这个s权限，是为了让一般使用者临时具有该文件所属主/组的执行权限。就比如/usr/bin/passwd在执行它的时候需要去修改/etc/passwd和/etc/shadow等文件，这些文件除了root外，其他用户都没有写权限，但是又为了能让普通用户修改自己的密码，只能时临时让他们具有root的权限。所以这个s权限就是用来完成这个特殊任务的。
[student2@rhel6 ~]$ ll /usr/bin/passwd
-rwsr-xr-x. 1 root root 30768 Feb 17  2012 /usr/bin/passwd
如果你不想让普通用户修改自己的密码，只需要
[root@localhost ~]# chmod u-s /usr/bin/passwd 或者
[root@localhost ~]# chmod 0755 /usr/bin/passwd

# t 禁止删除

t是针对执行权限来讲的，必须要先有x执行权限，t才有效。
t权限也可以直接用 chmod +t filename 和 chmod -t filename 来修改。小写t表示生效，大写T表示失效。
t权只针对目录生效，它表示只能让所属主以及root可以删除（重命名/移动）该目录下的文件。比如/tmp目录本来就是任何用户都可以读写，如果别人可以任意删除（重命名/移动）自己的文件，那岂不是很危险。比如我们赋予stu20用户在/test/目录为1777的权限即rwxrwxrwt，则对于目录本身stu20用户和root可以删除/test目录内的文件或目录，其它用户可以在里面创建文件或目录也可能删除相应的自己在里面创建的文件或目录但是不能删除其它用户的文件或目录。
[root@rhel6 /]# chmod 1777 test			#note:或chmod +t test && chmod 777 test
[root@rhel6 /]# ll -d test
drwxrwxrwt. 2 stu20 stu20 4096 Mar 10 16:58 test
[root@rhel6 /]# su - student
[student@rhel6 ~]$ cd /test
[student@rhel6 test]$ mkdir dir1
[student@rhel6 test]$ touch file1
[student@rhel6 test]$ ll
total 8
drwxrwxr-x. 2 student student 4096 Mar 10 17:17 dir1
-rw-rw-r--. 1 student student    0 Mar 10 17:17 file1
-rwsrwsrwt. 1 student student    6 Mar 10 16:58 test
[student@rhel6 test]$ rm -rf file1 
[student@rhel6 test]$ su - stu21
Password: 
[stu21@rhel6 ~]$ cd /test
[stu21@rhel6 test]$ ll
total 8
drwxrwxr-x. 2 student student 4096 Mar 10 17:17 dir1
-rwsrwsrwt. 1 student student    6 Mar 10 16:58 test
[stu21@rhel6 test]$ rm -rf dir1
rm: cannot remove `dir1': Operation not permitted

# a 只追加

a权限是'只追加'权限，可以给日志类或者其他需要的文件设置此权限。设置了a权限的文件只能进行追加，且不能使用文本编辑器追加。可以使用 chattr +a filename 和 chattr -a filename 设置a权限，使用 lsattr filename 查看特殊权限。

[root@localhost shell]# chattr +a test_a.py
[root@localhost shell]# lsattr test_a.py
-----a---------- test_a.py
[root@localhost shell]# echo "hello,world" > test_a.py  #不能将数据直接覆盖
bash: test_a.py: Operation not permitted
[root@localhost shell]# echo "hello,world" >> test_a.py #可以将数据追加到后面
如果我们试图使用vim等文本编辑器去修改具有a权限的文件的话，在保存的时候就会提示没有相应的权限 E212: Cannot open file for writing ，我这里是Vim给出的警告。

# i 不可修改

i权限是一个完全不可修改的权限，即使这个文件权限是777也必须要取消掉i权限才可以修改。我们还是使用 lsattr filename 查看i权限设置，然后使用 chattr +i filename 和 chattr -i filename 设置a权限。

[root@localhost shell]# lsattr test_i.py
---------------- test_i.py
[root@localhost shell]# chattr +i test_i.py
[root@localhost shell]# lsattr test_i.py
----i----------- test_i.py

#删除，覆盖，追加都不行
[root@localhost shell]# echo "hello,world" > test_i.py
bash: test_i.py: Permission denied
[root@localhost shell]# echo "hello,world" >> test_i.py
bash: test_i.py: Permission denied
[root@localhost shell]# rm test_i.py
rm: cannot remove ‘test_i.py’: Operation not permitted
```

